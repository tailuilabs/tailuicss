{"version":3,"sources":["/Users/hosmann/Projects/TailUI/dist/cli/index.cjs","../../src/cli/index.ts"],"names":["require"],"mappings":"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","file":"/Users/hosmann/Projects/TailUI/dist/cli/index.cjs","sourcesContent":[null,"#!/usr/bin/env node\n\nimport { program } from 'commander';\nimport fs from 'fs';\nimport path from 'path';\nimport readline from 'readline';\nimport https from 'https';\nimport { resolveConfig, CONFIG_FILE, DEFAULT_DIR } from '../config';\nimport { createRequire } from 'module';\n\nconst require = createRequire(import.meta.url);\nconst pkg = require('../../package.json') as { version: string };\n\n// Catch unhandled promise rejections (async commands)\nprocess.on('unhandledRejection', (err: unknown) => {\n  const message = err instanceof Error ? err.message : String(err);\n  console.error(`  âŒ Unexpected error: ${message}`);\n  process.exit(1);\n});\n\n// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ntype Stack = 'react' | 'nextjs' | 'vue' | 'nuxt' | 'svelte' | 'sveltekit' | 'angular' | 'astro' | 'html';\ntype AIProvider = 'openai' | 'claude' | 'gemini' | 'mistral';\n\ninterface AIEndpoint {\n  url: string;\n  model: string;\n}\n\ninterface AIConfig {\n  provider: AIProvider;\n  apiKey: string;\n}\n\ninterface TailUIConfig {\n  version?: string;\n  stack?: Stack;\n  directory?: string;\n  stylesDir?: string;\n  componentsDir?: string;\n  ai?: AIConfig;\n  components?: Record<string, string[]>;\n  variables?: Record<string, string[]>;\n  slots?: string[];\n}\n\ninterface AngularTemplate {\n  ts: () => string;\n  html: () => string;\n}\n\ninterface MigrateOptions {\n  target?: string;\n  all?: boolean;\n  dryRun?: boolean;\n  interactive?: boolean;\n  force?: boolean;\n  threshold?: number;\n  undo?: boolean;\n  ai?: boolean;\n  aiConfig?: AIConfig | null;\n}\n\n// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst STACKS: Stack[] = ['react', 'nextjs', 'vue', 'nuxt', 'svelte', 'sveltekit', 'angular', 'astro', 'html'];\nconst AI_PROVIDERS: AIProvider[] = ['openai', 'claude', 'gemini', 'mistral'];\nconst COMPONENT_NAME_RE = /^[a-z][a-z0-9-]*$/;\nconst TOKEN_NAME_RE = /^[a-z][a-z0-9-]*$/;\n\nconst AI_ENDPOINTS: Record<AIProvider, AIEndpoint> = {\n  openai:  { url: 'https://api.openai.com/v1/chat/completions', model: 'gpt-4o' },\n  claude:  { url: 'https://api.anthropic.com/v1/messages', model: 'claude-sonnet-4-20250514' },\n  gemini:  { url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent', model: 'gemini-pro' },\n  mistral: { url: 'https://api.mistral.ai/v1/chat/completions', model: 'mistral-large-latest' },\n};\n\nconst STACK_EXTENSIONS: Record<Stack, string> = {\n  react: 'tsx', nextjs: 'tsx', vue: 'vue', nuxt: 'vue',\n  svelte: 'svelte', sveltekit: 'svelte', angular: 'ts',\n  astro: 'astro', html: 'html',\n};\n\nprogram\n  .name('tailui')\n  .description('TailUI â€” Semantic CSS layer on top of TailwindCSS')\n  .version(pkg.version);\n\n// â”€â”€â”€ Helper: get styles dir from config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction getStylesDir(optionDir?: string): string {\n  if (optionDir) return optionDir;\n  const { stylesDir } = resolveConfig();\n  return stylesDir;\n}\n\nfunction loadConfig(): TailUIConfig | null {\n  const configPath = path.join(process.cwd(), CONFIG_FILE);\n  if (!fs.existsSync(configPath)) return null;\n  try {\n    return JSON.parse(fs.readFileSync(configPath, 'utf8')) as TailUIConfig;\n  } catch (e) {\n    console.error(`  âŒ Failed to parse ${CONFIG_FILE}: ${(e as Error).message}`);\n    console.error(`  Fix the JSON syntax or delete the file and run: npx tailui init`);\n    process.exit(1);\n  }\n}\n\nfunction saveConfig(config: TailUIConfig): void {\n  const configPath = path.join(process.cwd(), CONFIG_FILE);\n  try {\n    fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\\n');\n  } catch (e) {\n    console.error(`  âŒ Failed to write ${CONFIG_FILE}: ${(e as Error).message}`);\n    process.exit(1);\n  }\n}\n\n// â”€â”€â”€ CREATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('create <component>')\n  .description('Create a new UI component style file')\n  .option('-d, --dir <path>', 'Override styles directory')\n  .option('-v, --variants <variants>', 'Comma-separated list of variants', '')\n  .action((component: string, options: { dir?: string; variants?: string }) => {\n    if (!COMPONENT_NAME_RE.test(component)) {\n      console.error(`  âŒ Invalid component name \"${component}\". Use lowercase letters, numbers, and hyphens (e.g. \"my-button\").`);\n      process.exit(1);\n    }\n\n    const dir = getStylesDir(options.dir);\n    const filePath = path.join(dir, `ui.${component}.css`);\n\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir, { recursive: true });\n      console.log(`  ğŸ“ Created directory: ${dir}`);\n    }\n\n    if (fs.existsSync(filePath)) {\n      console.log(`  âš ï¸  Component \"${component}\" already exists at ${filePath}`);\n      process.exit(0);\n    }\n\n    const variants = options.variants\n      ? options.variants.split(',').map(v => v.trim()).filter(Boolean)\n      : ['default'];\n\n    const invalidVariant = variants.find(v => !TOKEN_NAME_RE.test(v));\n    if (invalidVariant) {\n      console.error(`  âŒ Invalid variant name \"${invalidVariant}\". Use lowercase letters, numbers, and hyphens.`);\n      process.exit(1);\n    }\n\n    const template = generateTemplate(component, variants);\n    fs.writeFileSync(filePath, template);\n    console.log(`  âœ… Created: ${filePath}`);\n\n    updateConfig(component, variants);\n    updateIndex(dir, component);\n\n    console.log(`\\n  Usage:`);\n    console.log(`    <div class=\"ui-${component}\">`);\n    variants.forEach(v => {\n      console.log(`    <div class=\"ui-${component} ui-${v}\">`);\n    });\n    console.log('');\n  });\n\n// â”€â”€â”€ ADD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('add <component>')\n  .description('Add a TailUI component to your project (CSS + framework component)')\n  .option('--css-only', 'Only copy the CSS file, skip framework component generation')\n  .option('--overwrite', 'Overwrite existing files')\n  .action(async (component: string, options: { cssOnly?: boolean; overwrite?: boolean }) => {\n    if (!COMPONENT_NAME_RE.test(component)) {\n      console.error(`  âŒ Invalid component name \"${component}\". Use lowercase letters, numbers, and hyphens.`);\n      process.exit(1);\n    }\n\n    const config = loadConfig();\n    if (!config) {\n      console.log('  âŒ No ui.config.json found. Run: npx tailui init');\n      process.exit(1);\n    }\n\n    const { getTemplate, getAvailableComponents } = require('../templates') as {\n      getTemplate: (component: string, stack: string, isTypeScript: boolean) => string | AngularTemplate | null;\n      getAvailableComponents: () => string[];\n      hasTemplate: (component: string) => boolean;\n    };\n\n    const availableComponents = getAvailableComponents();\n    if (!availableComponents.includes(component)) {\n      console.error(`  âŒ Component \"${component}\" not found in TailUI library.`);\n      console.error(`  Available components: ${availableComponents.join(', ')}`);\n      process.exit(1);\n    }\n\n    const stylesDir = config.stylesDir || './ui/styles';\n    const componentsDir = config.componentsDir || './src/components/ui';\n    const stack = config.stack || 'react';\n\n    const isTypeScript = fs.existsSync(path.join(process.cwd(), 'tsconfig.json'));\n\n    console.log(`\\n  ğŸ“¦ Adding ${component} component...\\n`);\n\n    // â”€â”€ Step 1: Copy CSS file â”€â”€\n    const cssSourcePath = path.join(__dirname, '../../ui/styles', `ui.${component}.css`);\n    const cssDestPath = path.join(stylesDir, `ui.${component}.css`);\n\n    if (!fs.existsSync(cssSourcePath)) {\n      console.error(`  âŒ CSS file not found: ${cssSourcePath}`);\n      process.exit(1);\n    }\n\n    if (!fs.existsSync(stylesDir)) {\n      fs.mkdirSync(stylesDir, { recursive: true });\n      console.log(`  ğŸ“ Created: ${stylesDir}`);\n    }\n\n    if (fs.existsSync(cssDestPath) && !options.overwrite) {\n      console.log(`  âš ï¸  ${cssDestPath} already exists. Use --overwrite to replace.`);\n    } else {\n      fs.copyFileSync(cssSourcePath, cssDestPath);\n      console.log(`  âœ… Copied: ${cssDestPath}`);\n      updateIndex(stylesDir, component);\n    }\n\n    // â”€â”€ Step 2: Generate framework component â”€â”€\n    if (!options.cssOnly) {\n      if (!fs.existsSync(componentsDir)) {\n        fs.mkdirSync(componentsDir, { recursive: true });\n        console.log(`  ğŸ“ Created: ${componentsDir}`);\n      }\n\n      const ext = getExtension(stack, isTypeScript);\n      const componentName = capitalize(component);\n\n      if (stack === 'angular') {\n        const template = getTemplate(component, stack, isTypeScript) as AngularTemplate | null;\n        if (template && 'ts' in template && 'html' in template) {\n          const tsPath = path.join(componentsDir, `${component}.component.ts`);\n          const htmlPath = path.join(componentsDir, `${component}.component.html`);\n\n          if (fs.existsSync(tsPath) && !options.overwrite) {\n            console.log(`  âš ï¸  ${tsPath} already exists. Use --overwrite to replace.`);\n          } else {\n            fs.writeFileSync(tsPath, template.ts());\n            console.log(`  âœ… Generated: ${tsPath}`);\n          }\n\n          if (fs.existsSync(htmlPath) && !options.overwrite) {\n            console.log(`  âš ï¸  ${htmlPath} already exists. Use --overwrite to replace.`);\n          } else {\n            fs.writeFileSync(htmlPath, template.html());\n            console.log(`  âœ… Generated: ${htmlPath}`);\n          }\n        } else {\n          console.log(`  â„¹ï¸  No Angular template for ${component}. CSS only.`);\n        }\n      } else {\n        const template = getTemplate(component, stack, isTypeScript) as string | null;\n        if (template) {\n          const fileName = `${componentName}.${ext}`;\n          const filePath = path.join(componentsDir, fileName);\n\n          if (fs.existsSync(filePath) && !options.overwrite) {\n            console.log(`  âš ï¸  ${filePath} already exists. Use --overwrite to replace.`);\n          } else {\n            fs.writeFileSync(filePath, template);\n            console.log(`  âœ… Generated: ${filePath}`);\n          }\n        } else {\n          console.log(`  â„¹ï¸  No ${stack} template for ${component}. CSS only.`);\n        }\n      }\n    }\n\n    // â”€â”€ Summary â”€â”€\n    console.log(`\\n  ğŸ‰ Done! Use the component:\\n`);\n    if (stack === 'react' || stack === 'nextjs') {\n      console.log(`  import { ${capitalize(component)} } from \"${componentsDir.replace('./', '@/')}/${capitalize(component)}\";`);\n    } else if (stack === 'vue' || stack === 'nuxt') {\n      console.log(`  <${capitalize(component)} />`);\n    } else if (stack === 'svelte' || stack === 'sveltekit') {\n      console.log(`  import ${capitalize(component)} from \"${componentsDir}/${capitalize(component)}.svelte\";`);\n    } else if (stack === 'angular') {\n      console.log(`  <ui-${component}></ui-${component}>`);\n    } else {\n      console.log(`  <div class=\"ui-${component}\">...</div>`);\n    }\n    console.log('');\n  });\n\nfunction getExtension(stack: string, isTypeScript: boolean): string {\n  const extensions: Record<string, string> = {\n    react: isTypeScript ? 'tsx' : 'jsx',\n    nextjs: isTypeScript ? 'tsx' : 'jsx',\n    vue: 'vue',\n    nuxt: 'vue',\n    svelte: 'svelte',\n    sveltekit: 'svelte',\n    angular: 'ts',\n    astro: 'astro',\n    html: 'html',\n  };\n  return extensions[stack] ?? (isTypeScript ? 'tsx' : 'jsx');\n}\n\n// â”€â”€â”€ LIST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('list')\n  .description('List all UI components and their tokens')\n  .action(() => {\n    const config = loadConfig();\n\n    if (!config) {\n      console.log('  âŒ No ui.config.json found. Run: npx tailui init');\n      process.exit(1);\n    }\n\n    const components = config.components || {};\n\n    console.log('\\n  ğŸ“¦ TailUI Components\\n');\n    console.log(`  Stack: ${config.stack || 'not set'}`);\n    console.log(`  Directory: ${config.directory || 'not set'}`);\n    console.log(`  Components dir: ${config.componentsDir || 'not set'}`);\n    console.log(`  AI: ${config.ai?.provider || 'not configured'}\\n`);\n\n    if (Object.keys(components).length === 0) {\n      console.log('  No components found.\\n');\n      return;\n    }\n\n    for (const [name, tokens] of Object.entries(components)) {\n      console.log(`  ${name}`);\n      if (Array.isArray(tokens)) {\n        tokens.forEach(t => console.log(`    â”œâ”€ ${t}`));\n      }\n      console.log('');\n    }\n  });\n\n// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('init')\n  .description('Initialize TailUI in the current project')\n  .option('-d, --dir <name>', 'Directory name (skip prompt)')\n  .option('-s, --stack <stack>', 'Framework stack (skip prompt)')\n  .action(async (options: { dir?: string; stack?: string }) => {\n    const configPath = path.join(process.cwd(), CONFIG_FILE);\n\n    if (fs.existsSync(configPath)) {\n      const existing = loadConfig();\n      if (existing) {\n        console.log(`\\n  âš ï¸  TailUI is already initialized.`);\n        console.log(`  Directory: ${existing.stylesDir}`);\n        console.log(`  Stack: ${existing.stack || 'not set'}`);\n        console.log(`  Config: ${CONFIG_FILE}\\n`);\n        return;\n      }\n    }\n\n    console.log('\\n  ğŸ¨ TailUI Setup\\n');\n\n    // â”€â”€ Step 1: Stack â”€â”€\n    let stack: string;\n    if (options.stack && STACKS.includes(options.stack as Stack)) {\n      stack = options.stack;\n    } else {\n      console.log('  What is your project stack?\\n');\n      STACKS.forEach((s, i) => console.log(`    ${i + 1}. ${s}`));\n      console.log(`    0. other\\n`);\n\n      const stackChoice = await askQuestion('  Enter number (1)', '1');\n      const idx = parseInt(stackChoice, 10);\n      if (idx === 0) {\n        stack = await askQuestion('  Enter your stack name:', 'html');\n      } else if (idx >= 1 && idx <= STACKS.length) {\n        stack = STACKS[idx - 1];\n      } else {\n        stack = STACKS[0];\n      }\n    }\n    console.log(`  â†’ Stack: ${stack}\\n`);\n\n    // â”€â”€ Step 2: Styles directory â”€â”€\n    let dirName: string;\n    if (options.dir) {\n      dirName = options.dir;\n    } else {\n      dirName = await askQuestion(\n        `  Where should TailUI store styles? (${DEFAULT_DIR})`,\n        DEFAULT_DIR\n      );\n    }\n    dirName = dirName.replace(/[^a-zA-Z0-9_\\-./]/g, '').trim() || DEFAULT_DIR;\n    const stylesDir = `./${dirName}/styles`;\n\n    const resolvedStylesDir = path.resolve(process.cwd(), stylesDir);\n    if (!resolvedStylesDir.startsWith(process.cwd())) {\n      console.error(`  âŒ Styles directory must be within the project.`);\n      process.exit(1);\n    }\n    console.log(`  â†’ Styles: ${stylesDir}\\n`);\n\n    // â”€â”€ Step 3: Components directory â”€â”€\n    const defaultComponentsDir = `./src/components/ui`;\n    let componentsDir = await askQuestion(\n      `  Where should generated components be placed? (${defaultComponentsDir})`,\n      defaultComponentsDir\n    );\n    componentsDir = componentsDir.replace(/[^a-zA-Z0-9_\\-./]/g, '').trim() || defaultComponentsDir;\n\n    const resolvedComponentsDir = path.resolve(process.cwd(), componentsDir);\n    if (!resolvedComponentsDir.startsWith(process.cwd())) {\n      console.error(`  âŒ Components directory must be within the project.`);\n      process.exit(1);\n    }\n    console.log(`  â†’ Components: ${componentsDir}\\n`);\n\n    // â”€â”€ Step 4: AI configuration (optional) â”€â”€\n    const configureAI = await askQuestion('  Configure AI for component generation? (y/N)', 'n');\n\n    let ai: AIConfig | null = null;\n    if (configureAI.toLowerCase() === 'y') {\n      console.log('\\n  Choose your AI provider:\\n');\n      AI_PROVIDERS.forEach((p, i) => console.log(`    ${i + 1}. ${p}`));\n      console.log('');\n\n      const providerChoice = await askQuestion('  Enter number (1)', '1');\n      const pIdx = parseInt(providerChoice, 10);\n      const provider: AIProvider = (pIdx >= 1 && pIdx <= AI_PROVIDERS.length)\n        ? AI_PROVIDERS[pIdx - 1]\n        : AI_PROVIDERS[0];\n\n      const apiKey = await askQuestion(`  Enter your ${provider} API key:`, '');\n\n      if (apiKey) {\n        ai = { provider, apiKey };\n        console.log(`  â†’ AI: ${provider} âœ…\\n`);\n      } else {\n        console.log('  â†’ AI: skipped (no key provided)\\n');\n      }\n    }\n\n    // â”€â”€ Check existing directory â”€â”€\n    if (fs.existsSync(dirName) && fs.readdirSync(dirName).length > 0) {\n      const overwrite = await askQuestion(\n        `  âš ï¸  Directory \"${dirName}\" already exists. Use it anyway? (y/N)`,\n        'n'\n      );\n      if (overwrite.toLowerCase() !== 'y') {\n        console.log('  Aborted.\\n');\n        return;\n      }\n    }\n\n    // â”€â”€ Create directories â”€â”€\n    if (!fs.existsSync(stylesDir)) {\n      fs.mkdirSync(stylesDir, { recursive: true });\n      console.log(`  ğŸ“ Created: ${stylesDir}`);\n    }\n\n    if (!fs.existsSync(componentsDir)) {\n      fs.mkdirSync(componentsDir, { recursive: true });\n      console.log(`  ğŸ“ Created: ${componentsDir}`);\n    }\n\n    const indexPath = path.join(stylesDir, 'index.css');\n    if (!fs.existsSync(indexPath)) {\n      fs.writeFileSync(indexPath, `/* TailUI â€” Component Styles Entry Point */\\n`);\n      console.log(`  ğŸ“„ Created: ${indexPath}`);\n    }\n\n    // â”€â”€ Create config â”€â”€\n    const config: TailUIConfig = {\n      version: '1.0.0',\n      stack: stack as Stack,\n      directory: dirName,\n      stylesDir,\n      componentsDir,\n      ...(ai ? { ai } : {}),\n      components: {},\n      variables: {},\n    };\n    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));\n    console.log(`  ğŸ“„ Created: ${CONFIG_FILE}`);\n\n    if (ai) {\n      const gitignorePath = path.join(process.cwd(), '.gitignore');\n      if (fs.existsSync(gitignorePath)) {\n        const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');\n        if (!gitignoreContent.includes(CONFIG_FILE)) {\n          fs.appendFileSync(gitignorePath, `\\n# TailUI config (contains API key)\\n${CONFIG_FILE}\\n`);\n          console.log(`  ğŸ”’ Added ${CONFIG_FILE} to .gitignore (API key protection)`);\n        }\n      } else {\n        fs.writeFileSync(gitignorePath, `# TailUI config (contains API key)\\n${CONFIG_FILE}\\n`);\n        console.log(`  ğŸ”’ Created .gitignore with ${CONFIG_FILE} (API key protection)`);\n      }\n    }\n\n    console.log('\\n  âœ… TailUI initialized!\\n');\n    console.log('  Next steps:\\n');\n    console.log('    1. Add to tailwind.config.js:');\n    console.log(`       plugins: [require('@tailuicss/core')()]`);\n    console.log('');\n    console.log('    2. Add to postcss.config.js:');\n    console.log(`       plugins: { '@tailuicss/core/postcss': {}, tailwindcss: {} }`);\n    console.log('');\n    console.log('    3. Your CSS file just needs:');\n    console.log('       @tailwind base;');\n    console.log('       @tailwind components;');\n    console.log('       @tailwind utilities;');\n    console.log('');\n    if (ai) {\n      console.log('    4. Generate a component with AI:');\n      console.log('       npx tailui generate button');\n    } else {\n      console.log('    4. Create your first component:');\n      console.log('       npx tailui create button --variants primary,secondary,danger');\n    }\n    console.log('');\n  });\n\n// â”€â”€â”€ GENERATE (AI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('generate <component>')\n  .description('Generate a framework component with AI using TailUI styles')\n  .option('-s, --stack <stack>', 'Override stack from config')\n  .action(async (component: string, options: { stack?: string }) => {\n    if (!COMPONENT_NAME_RE.test(component)) {\n      console.error(`  âŒ Invalid component name \"${component}\". Use lowercase letters, numbers, and hyphens.`);\n      process.exit(1);\n    }\n\n    const config = loadConfig();\n\n    if (!config) {\n      console.log('  âŒ No ui.config.json found. Run: npx tailui init');\n      process.exit(1);\n    }\n\n    if (!config.ai?.apiKey) {\n      console.log('  âŒ AI not configured. Run: npx tailui init');\n      console.log('  Or add manually to ui.config.json:');\n      console.log('    \"ai\": { \"provider\": \"openai\", \"apiKey\": \"sk-...\" }');\n      process.exit(1);\n    }\n\n    const stack = options.stack || config.stack || 'react';\n    const provider = config.ai.provider;\n    const apiKey = config.ai.apiKey;\n    const componentsDir = config.componentsDir || './src/components/ui';\n    const stylesDir = config.stylesDir || './ui/styles';\n    const ext = STACK_EXTENSIONS[stack as Stack] || 'tsx';\n\n    const cssPath = path.join(stylesDir, `ui.${component}.css`);\n    let cssContent = '';\n    if (fs.existsSync(cssPath)) {\n      cssContent = fs.readFileSync(cssPath, 'utf8');\n    }\n\n    console.log(`\\n  ğŸ¤– Generating ${component} component for ${stack}...`);\n    console.log(`  Provider: ${provider}\\n`);\n\n    const prompt = buildPrompt(component, stack, cssContent, config);\n\n    try {\n      const code = await callAI(provider, apiKey, prompt);\n\n      if (!fs.existsSync(componentsDir)) {\n        fs.mkdirSync(componentsDir, { recursive: true });\n      }\n\n      const fileName = `${capitalize(component)}.${ext}`;\n      const filePath = path.join(componentsDir, fileName);\n\n      if (fs.existsSync(filePath)) {\n        const overwrite = await askQuestion(\n          `  âš ï¸  ${fileName} already exists. Overwrite? (y/N)`,\n          'n'\n        );\n        if (overwrite.toLowerCase() !== 'y') {\n          console.log('  Aborted.\\n');\n          return;\n        }\n      }\n\n      fs.writeFileSync(filePath, code);\n      console.log(`  âœ… Generated: ${filePath}`);\n      console.log(`\\n  The component uses TailUI .ui-* classes from your styles.`);\n      console.log(`  Import it in your project and start using it!\\n`);\n    } catch (err) {\n      console.error(`  âŒ AI generation failed: ${(err as Error).message}`);\n      console.error('  Check your API key and network connection.\\n');\n      process.exit(1);\n    }\n  });\n\n// â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('config')\n  .description('View or update TailUI configuration')\n  .option('--set-ai <provider>', 'Set AI provider (openai, claude, gemini, mistral)')\n  .option('--set-key <key>', 'Set AI API key')\n  .option('--set-stack <stack>', 'Set project stack')\n  .action((options: { setAi?: string; setKey?: string; setStack?: string }) => {\n    const config = loadConfig();\n\n    if (!config) {\n      console.log('  âŒ No ui.config.json found. Run: npx tailui init');\n      process.exit(1);\n    }\n\n    let changed = false;\n\n    if (options.setStack) {\n      if (!STACKS.includes(options.setStack as Stack)) {\n        console.error(`  âŒ Invalid stack \"${options.setStack}\". Must be one of: ${STACKS.join(', ')}`);\n        process.exit(1);\n      }\n      config.stack = options.setStack as Stack;\n      changed = true;\n      console.log(`  âœ… Stack set to: ${options.setStack}`);\n    }\n\n    if (options.setAi) {\n      if (!AI_PROVIDERS.includes(options.setAi as AIProvider)) {\n        console.error(`  âŒ Invalid AI provider \"${options.setAi}\". Must be one of: ${AI_PROVIDERS.join(', ')}`);\n        process.exit(1);\n      }\n      if (!config.ai) config.ai = { provider: options.setAi as AIProvider, apiKey: '' };\n      config.ai.provider = options.setAi as AIProvider;\n      changed = true;\n      console.log(`  âœ… AI provider set to: ${options.setAi}`);\n    }\n\n    if (options.setKey) {\n      if (!config.ai) config.ai = { provider: 'openai', apiKey: '' };\n      config.ai.apiKey = options.setKey;\n      changed = true;\n      console.log(`  âœ… AI API key updated`);\n\n      const gitignorePath = path.join(process.cwd(), '.gitignore');\n      if (fs.existsSync(gitignorePath)) {\n        const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');\n        if (!gitignoreContent.includes(CONFIG_FILE)) {\n          fs.appendFileSync(gitignorePath, `\\n# TailUI config (contains API key)\\n${CONFIG_FILE}\\n`);\n          console.log(`  ğŸ”’ Added ${CONFIG_FILE} to .gitignore (API key protection)`);\n        }\n      }\n    }\n\n    if (changed) {\n      saveConfig(config);\n      console.log(`  ğŸ“ Saved: ${CONFIG_FILE}\\n`);\n    } else {\n      console.log('\\n  âš™ï¸  TailUI Configuration\\n');\n      console.log(`  Stack:          ${config.stack || 'not set'}`);\n      console.log(`  Directory:      ${config.directory || 'not set'}`);\n      console.log(`  Styles dir:     ${config.stylesDir || 'not set'}`);\n      console.log(`  Components dir: ${config.componentsDir || 'not set'}`);\n      console.log(`  AI provider:    ${config.ai?.provider || 'not configured'}`);\n      console.log(`  AI key:         ${config.ai?.apiKey ? 'â€¢â€¢â€¢â€¢' + config.ai.apiKey.slice(-4) : 'not set'}`);\n      console.log('');\n    }\n  });\n\n// â”€â”€â”€ MIGRATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nprogram\n  .command('migrate [target]')\n  .description('Migrate Tailwind utility classes to TailUI .ui-* semantic classes')\n  .option('-f, --file <path>', 'Migrate a single file')\n  .option('--all', 'Migrate all supported files in the target directory')\n  .option('--dry-run', 'Preview changes without modifying files')\n  .option('-i, --interactive', 'Confirm each migration interactively')\n  .option('--force', 'Apply all migrations without confirmation')\n  .option('--threshold <number>', 'Minimum confidence score (0â€“100, default 60)', '60')\n  .option('--undo', 'Restore files from the most recent backup')\n  .action(async (target: string | undefined, options: {\n    file?: string;\n    all?: boolean;\n    dryRun?: boolean;\n    interactive?: boolean;\n    force?: boolean;\n    threshold?: string;\n    undo?: boolean;\n  }) => {\n    const { migrate } = require('../migrate') as { migrate: (opts: MigrateOptions) => Promise<void> };\n\n    if (options.undo) {\n      return migrate({ undo: true });\n    }\n\n    const resolvedTarget = options.file || target;\n\n    if (!resolvedTarget) {\n      console.error('  âŒ Please specify a target file or directory.');\n      console.error('');\n      console.error('  Usage:');\n      console.error('    tailui migrate -f <file>           Migrate a single file');\n      console.error('    tailui migrate --all <directory>    Migrate all files in a directory');\n      console.error('    tailui migrate --undo               Restore from backup');\n      console.error('');\n      console.error('  Examples:');\n      console.error('    tailui migrate -f src/components/Button.tsx');\n      console.error('    tailui migrate --all src/components');\n      console.error('    tailui migrate --all src/components --dry-run');\n      console.error('    tailui migrate --all src/components -i');\n      console.error('');\n      process.exit(1);\n    }\n\n    const threshold = parseInt(options.threshold ?? '60', 10);\n    if (isNaN(threshold) || threshold < 0 || threshold > 100) {\n      console.error('  âŒ Threshold must be a number between 0 and 100.');\n      process.exit(1);\n    }\n\n    let aiConfig: AIConfig | null = null;\n    const config = loadConfig();\n    if (config?.ai?.apiKey) {\n      aiConfig = config.ai;\n    }\n\n    await migrate({\n      target: resolvedTarget,\n      all: !!options.all,\n      dryRun: !!options.dryRun,\n      interactive: !!options.interactive,\n      force: !!options.force,\n      threshold,\n      undo: false,\n      ai: false,\n      aiConfig,\n    });\n  });\n\n// â”€â”€â”€ AI HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction buildPrompt(component: string, stack: string, cssContent: string, config: TailUIConfig = {}): string {\n  const componentName = capitalize(component);\n\n  const cssContext = cssContent\n    ? `\\nHere are the existing TailUI CSS styles for this component:\\n\\`\\`\\`css\\n${cssContent}\\n\\`\\`\\`\\nUse the .ui-* classes defined above.`\n    : `\\nUse TailUI .ui-${component} classes (e.g. class=\"ui-${component} ui-primary\").`;\n\n  let tokensContext = '';\n  const tokens = config.components?.[component];\n  if (Array.isArray(tokens) && tokens.length > 0) {\n    tokensContext = `\\nAvailable variants/tokens for this component: ${tokens.map(t => `ui-${t}`).join(', ')}`;\n    tokensContext += `\\nExpose these as typed props (e.g. variant, size, state).`;\n  }\n\n  let slotsContext = '';\n  const slots = config.slots;\n  if (Array.isArray(slots) && slots.length > 0) {\n    const usedSlots = cssContent\n      ? slots.filter(s => cssContent.includes(`.ui-${s}`))\n      : [];\n    if (usedSlots.length > 0) {\n      slotsContext = `\\nThis component uses the following sub-element slots: ${usedSlots.map(s => `.ui-${s}`).join(', ')}`;\n      slotsContext += `\\nRender these as named children/sections in the component (e.g. header, body, footer slots).`;\n    }\n  }\n\n  let varsContext = '';\n  const vars = config.variables?.[component];\n  if (Array.isArray(vars) && vars.length > 0) {\n    varsContext = `\\nThis component supports CSS custom properties: ${vars.join(', ')}`;\n    varsContext += `\\nExpose these as optional style props.`;\n  }\n\n  const stackInstructions: Record<string, string> = {\n    react: `Create a React (TSX) functional component named ${componentName}. Use TypeScript with proper props interface. Export as default.`,\n    nextjs: `Create a Next.js (TSX) component named ${componentName}. Add \"use client\" if needed. Use TypeScript with proper props interface. Export as default.`,\n    vue: `Create a Vue 3 SFC (.vue) component named ${componentName}. Use <script setup lang=\"ts\"> with defineProps.`,\n    nuxt: `Create a Nuxt 3 SFC (.vue) component named ${componentName}. Use <script setup lang=\"ts\"> with defineProps.`,\n    svelte: `Create a Svelte component named ${componentName}. Use TypeScript with export let for props.`,\n    sveltekit: `Create a SvelteKit component named ${componentName}. Use TypeScript with export let for props.`,\n    angular: `Create an Angular standalone component named ${componentName}Component. Use TypeScript with @Input() decorators.`,\n    astro: `Create an Astro component named ${componentName}. Use frontmatter for props.`,\n    html: `Create a pure HTML snippet for the ${componentName} component with example usage.`,\n  };\n\n  const instruction = stackInstructions[stack] ?? stackInstructions.react;\n\n  return `You are a senior frontend developer. Generate a production-ready UI component.\n\n${instruction}\n${cssContext}${tokensContext}${slotsContext}${varsContext}\n\nRequirements:\n- Use TailUI .ui-* CSS classes for styling (NOT inline Tailwind utility classes)\n- Include all common props (variants, sizes, disabled, etc.)\n- Include proper TypeScript types where applicable\n- Make it accessible (aria attributes, keyboard navigation)\n- Include JSDoc/comments for the component\n- Output ONLY the component code, no explanations\n\nComponent: ${componentName}`;\n}\n\nfunction callAI(provider: AIProvider, apiKey: string, prompt: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const endpoint = AI_ENDPOINTS[provider];\n    if (!endpoint) {\n      return reject(new Error(`Unknown AI provider: ${provider}`));\n    }\n\n    let body: string;\n    let headers: Record<string, string>;\n    let requestUrl = endpoint.url;\n\n    if (provider === 'claude') {\n      body = JSON.stringify({\n        model: endpoint.model,\n        max_tokens: 4096,\n        messages: [{ role: 'user', content: prompt }],\n      });\n      headers = {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n      };\n    } else if (provider === 'gemini') {\n      body = JSON.stringify({\n        contents: [{ parts: [{ text: prompt }] }],\n      });\n      headers = { 'Content-Type': 'application/json' };\n      requestUrl = `${endpoint.url}?key=${apiKey}`;\n    } else {\n      body = JSON.stringify({\n        model: endpoint.model,\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: 4096,\n        temperature: 0.3,\n      });\n      headers = {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      };\n    }\n\n    const url = new URL(requestUrl);\n    const reqOptions: https.RequestOptions = {\n      hostname: url.hostname,\n      path: url.pathname + url.search,\n      method: 'POST',\n      headers,\n    };\n\n    const req = https.request(reqOptions, (res) => {\n      let data = '';\n      res.on('data', (chunk: Buffer) => data += chunk);\n      res.on('end', () => {\n        if ((res.statusCode ?? 0) >= 400) {\n          const hint = res.statusCode === 401 ? ' (invalid API key?)'\n            : res.statusCode === 429 ? ' (rate limited â€” try again later)'\n            : res.statusCode === 403 ? ' (forbidden â€” check API key permissions)'\n            : '';\n          return reject(new Error(`${provider} API returned HTTP ${res.statusCode}${hint}: ${data.substring(0, 200)}`));\n        }\n\n        try {\n          const json = JSON.parse(data) as Record<string, unknown>;\n\n          let content: string | undefined;\n          if (provider === 'claude') {\n            content = (json.content as Array<{ text: string }>)?.[0]?.text;\n          } else if (provider === 'gemini') {\n            content = (json as { candidates?: Array<{ content?: { parts?: Array<{ text: string }> } }> })\n              .candidates?.[0]?.content?.parts?.[0]?.text;\n          } else {\n            content = (json as { choices?: Array<{ message?: { content: string } }> })\n              .choices?.[0]?.message?.content;\n          }\n\n          if (!content) {\n            return reject(new Error(`Empty response from ${provider}: ${data.substring(0, 200)}`));\n          }\n\n          const codeMatch = content.match(/```(?:\\w+)?\\n([\\s\\S]*?)```/);\n          resolve(codeMatch ? codeMatch[1].trim() : content.trim());\n        } catch (e) {\n          reject(new Error(`Failed to parse ${provider} response: ${(e as Error).message}`));\n        }\n      });\n    });\n\n    req.on('error', reject);\n    req.write(body);\n    req.end();\n  });\n}\n\n// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction askQuestion(prompt: string, defaultValue: string): Promise<string> {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(`${prompt} `, (answer: string) => {\n      rl.close();\n      resolve(answer.trim() || defaultValue);\n    });\n  });\n}\n\nfunction generateTemplate(component: string, variants: string[]): string {\n  let css = `@layer components {\\n`;\n  css += `  /* Base */\\n`;\n  css += `  .ui-${component} {\\n`;\n  css += `    @apply ;\\n`;\n  css += `  }\\n`;\n\n  variants.forEach(variant => {\n    css += `\\n  /* ${capitalize(variant)} */\\n`;\n    css += `  .ui-${component}.ui-${variant} {\\n`;\n    css += `    @apply ;\\n`;\n    css += `  }\\n`;\n  });\n\n  css += `}\\n`;\n  return css;\n}\n\nfunction updateConfig(component: string, tokens: string[]): void {\n  const config = loadConfig() ?? {};\n  if (!config.components) config.components = {};\n  config.components[component] = tokens;\n  saveConfig(config);\n  console.log(`  ğŸ“ Updated: ${CONFIG_FILE}`);\n}\n\nfunction updateIndex(dir: string, component: string): void {\n  const indexPath = path.join(dir, 'index.css');\n  const importLine = `@import \"./ui.${component}.css\";`;\n\n  if (fs.existsSync(indexPath)) {\n    const content = fs.readFileSync(indexPath, 'utf8');\n    if (!content.includes(importLine)) {\n      fs.appendFileSync(indexPath, `${importLine}\\n`);\n      console.log(`  ğŸ“ Updated: ${indexPath}`);\n    }\n  }\n}\n\nfunction capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nprogram.parse();"]}